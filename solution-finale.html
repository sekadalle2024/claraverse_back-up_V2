<!DOCTYPE html>
<html lang="fr">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Solution Finale</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1000px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }

        .container {
            background: white;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            margin-bottom: 20px;
        }

        .test-table {
            border-collapse: collapse;
            width: 100%;
            margin: 10px 0;
        }

        .test-table th,
        .test-table td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }

        .test-table th {
            background-color: #f2f2f2;
        }

        .prose {
            max-width: none;
        }

        button {
            background: #007bff;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            margin: 5px;
        }

        button:hover {
            background: #0056b3;
        }

        button.success {
            background: #28a745;
        }

        .logs-container {
            background: #1e1e1e;
            color: #ffffff;
            border-radius: 8px;
            padding: 20px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.4;
            max-height: 400px;
            overflow-y: auto;
            white-space: pre-wrap;
        }

        .log-entry {
            margin: 2px 0;
            padding: 2px 0;
        }

        .log-success {
            color: #4CAF50;
        }

        .log-error {
            color: #f44336;
        }

        .log-warning {
            color: #ff9800;
        }

        .log-info {
            color: #2196F3;
        }

        .status-box {
            padding: 15px;
            border-radius: 8px;
            margin: 10px 0;
            font-weight: bold;
            text-align: center;
        }

        .status-success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .status-error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
    </style>
</head>

<body>
    <div class="container">
        <h1>üéØ Solution Finale</h1>
        <p>Test avec correction du probl√®me de cache DOM identifi√©</p>

        <div id="status-box" class="status-box status-error">
            üîÑ Pr√™t pour le test final...
        </div>

        <div class="container">
            <h2>üéØ Test Final</h2>
            <button onclick="testSolutionFinale()">üéØ Solution Finale</button>
            <button onclick="testMultipleVerifications()">üîç V√©rifications Multiples</button>
            <button onclick="clearLogs()">üßπ Effacer</button>
        </div>

        <div class="container">
            <h2>üìã Table de Test</h2>
            <div class="prose prose-base dark:prose-invert max-w-none">
                <table id="test-table" class="test-table min-w-full">
                    <thead>
                        <tr>
                            <th>Test</th>
                            <th>Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Original</td>
                            <td>Data</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>

        <div class="container">
            <h2>üìä Logs</h2>
            <div id="logs-display" class="logs-container">
                <div class="log-entry log-info">[INIT] Solution finale pr√™te</div>
            </div>
        </div>
    </div>

    <!-- Charger le syst√®me de stockage -->
    <script src="menu_storage.js"></script>

    <script>
        function log(message, type = 'info') {
            const timestamp = new Date().toLocaleTimeString();
            const logEntry = document.createElement('div');
            logEntry.className = `log-entry log-${type}`;
            logEntry.textContent = `[${timestamp}] ${message}`;

            const logsContainer = document.getElementById('logs-display');
            logsContainer.appendChild(logEntry);
            logsContainer.scrollTop = logsContainer.scrollHeight;

            console.log(`[${timestamp}] ${message}`);
        }

        function clearLogs() {
            document.getElementById('logs-display').innerHTML = '';
            log('Logs effac√©s', 'info');
        }

        function updateStatus(message, type = 'info') {
            const statusBox = document.getElementById('status-box');
            statusBox.className = `status-box status-${type}`;
            statusBox.textContent = message;
        }

        // Fonction pour lire le contenu avec plusieurs m√©thodes
        function readCellContent(cell) {
            const methods = {
                textContent: cell.textContent,
                innerText: cell.innerText,
                innerHTML: cell.innerHTML,
                nodeValue: cell.firstChild ? cell.firstChild.nodeValue : null,
                data: cell.firstChild ? cell.firstChild.data : null
            };

            log(`üîç Lecture cellule:`, 'debug');
            Object.entries(methods).forEach(([method, value]) => {
                log(`  ${method}: "${value}"`, 'debug');
            });

            return methods;
        }

        // Fonction pour forcer le rafra√Æchissement DOM
        function forceRefresh(element) {
            // M√©thode 1: Forcer un reflow
            element.offsetHeight;

            // M√©thode 2: Cloner et remplacer
            const parent = element.parentNode;
            const nextSibling = element.nextSibling;
            parent.removeChild(element);
            parent.insertBefore(element, nextSibling);

            log('üîÑ DOM forc√© √† se rafra√Æchir', 'debug');
        }

        async function testSolutionFinale() {
            log('üéØ === SOLUTION FINALE ===', 'info');
            updateStatus('üîÑ Test en cours...', 'info');

            try {
                const table = document.getElementById('test-table');
                const firstCell = table.querySelector('td');
                const testContent = 'SOLUTION_FINALE_' + Date.now();

                // Phase 1: Pr√©paration
                log('üìã Phase 1: Pr√©paration', 'info');
                table.removeAttribute('data-robust-table-id');
                firstCell.textContent = testContent;
                log(`Contenu d√©fini: "${testContent}"`, 'info');

                // Phase 2: Sauvegarde
                log('üíæ Phase 2: Sauvegarde', 'info');
                const saveResult = window.claraverseStorageAPI.saveTable(table);
                log(`Sauvegarde: ${saveResult ? 'SUCC√àS' : '√âCHEC'}`, saveResult ? 'success' : 'error');

                if (saveResult) {
                    // Phase 3: Modification
                    log('üìù Phase 3: Modification', 'info');
                    firstCell.textContent = 'CONTENU_TEMPORAIRE_FINAL';
                    log(`Contenu modifi√©: "${firstCell.textContent}"`, 'info');

                    // Phase 4: Restauration
                    log('üîÑ Phase 4: Restauration', 'info');
                    const restoreResult = window.claraverseStorageAPI.restoreTable(table);
                    log(`Restauration: ${restoreResult ? 'SUCC√àS' : '√âCHEC'}`, restoreResult ? 'success' : 'error');

                    // Phase 5: V√©rifications multiples avec d√©lais
                    log('üîç Phase 5: V√©rifications multiples', 'info');

                    const verifications = [0, 50, 100, 200, 500];

                    for (const delay of verifications) {
                        await new Promise(resolve => setTimeout(resolve, delay));

                        log(`üîç V√©rification apr√®s ${delay}ms:`, 'info');

                        // Forcer le rafra√Æchissement
                        if (delay > 0) {
                            forceRefresh(firstCell);
                        }

                        // Lire avec plusieurs m√©thodes
                        const content = readCellContent(firstCell);

                        // V√©rifier si au moins une m√©thode donne le bon r√©sultat
                        const correctMethods = Object.entries(content).filter(([method, value]) =>
                            value === testContent
                        );

                        if (correctMethods.length > 0) {
                            log(`‚úÖ Contenu correct trouv√© avec: ${correctMethods.map(([m]) => m).join(', ')}`, 'success');
                            updateStatus('‚úÖ SOLUTION FINALE R√âUSSIE !', 'success');
                            return;
                        } else {
                            log(`‚ùå Aucune m√©thode ne donne le bon contenu apr√®s ${delay}ms`, 'warning');
                        }
                    }

                    log('‚ùå SOLUTION FINALE √âCHOU√âE apr√®s toutes les v√©rifications', 'error');
                    updateStatus('‚ùå Solution finale √©chou√©e', 'error');
                }

            } catch (error) {
                log(`‚ùå ERREUR: ${error.message}`, 'error');
                updateStatus('‚ùå Erreur lors du test', 'error');
            }
        }

        async function testMultipleVerifications() {
            log('üîç === TEST V√âRIFICATIONS MULTIPLES ===', 'info');

            try {
                const table = document.getElementById('test-table');
                const firstCell = table.querySelector('td');
                const testContent = 'MULTI_VERIF_' + Date.now();

                // Pr√©parer
                table.removeAttribute('data-robust-table-id');
                firstCell.textContent = testContent;

                // Sauvegarder
                const saveResult = window.claraverseStorageAPI.saveTable(table);
                if (saveResult) {
                    // Modifier
                    firstCell.textContent = 'TEMP_MULTI';

                    // Restaurer
                    const restoreResult = window.claraverseStorageAPI.restoreTable(table);

                    if (restoreResult) {
                        // V√©rifications avec diff√©rentes strat√©gies
                        const strategies = [
                            {
                                name: 'Imm√©diate',
                                delay: 0,
                                refresh: false
                            },
                            {
                                name: 'Avec d√©lai 50ms',
                                delay: 50,
                                refresh: false
                            },
                            {
                                name: 'Avec rafra√Æchissement',
                                delay: 100,
                                refresh: true
                            },
                            {
                                name: 'Re-s√©lection DOM',
                                delay: 150,
                                refresh: false,
                                reselect: true
                            },
                            {
                                name: 'Force reflow',
                                delay: 200,
                                refresh: false,
                                reflow: true
                            }
                        ];

                        for (const strategy of strategies) {
                            await new Promise(resolve => setTimeout(resolve, strategy.delay));

                            let cellToCheck = firstCell;

                            if (strategy.reselect) {
                                cellToCheck = document.getElementById('test-table').querySelector('td');
                                log(`üîÑ Re-s√©lection DOM effectu√©e`, 'debug');
                            }

                            if (strategy.refresh) {
                                forceRefresh(cellToCheck);
                            }

                            if (strategy.reflow) {
                                // Forcer un reflow complet
                                document.body.offsetHeight;
                                cellToCheck.offsetHeight;
                                log(`üîÑ Reflow forc√©`, 'debug');
                            }

                            const content = cellToCheck.textContent;
                            log(`üîç ${strategy.name}: "${content}"`, content === testContent ? 'success' : 'warning');

                            if (content === testContent) {
                                log(`‚úÖ SUCC√àS avec strat√©gie: ${strategy.name}`, 'success');
                                updateStatus(`‚úÖ R√©ussi avec: ${strategy.name}`, 'success');
                                return;
                            }
                        }

                        log('‚ùå Toutes les strat√©gies ont √©chou√©', 'error');
                        updateStatus('‚ùå Toutes les strat√©gies √©chou√©es', 'error');
                    }
                }

            } catch (error) {
                log(`‚ùå ERREUR: ${error.message}`, 'error');
            }
        }

        // Initialisation
        document.addEventListener('DOMContentLoaded', function () {
            log('üéØ Solution finale charg√©e', 'success');
            log('üí° Bas√© sur le diagnostic: probl√®me de cache DOM identifi√©', 'info');
        });
    </script>
</body>

</html>