<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tests des Cas Limites</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1000px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            background: white;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }
        .test-table {
            border-collapse: collapse;
            width: 100%;
            margin: 10px 0;
        }
        .test-table th, .test-table td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }
        .test-table th {
            background-color: #f2f2f2;
        }
        .prose {
            max-width: none;
        }
        button {
            background: #007bff;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            margin: 5px;
        }
        button:hover { background: #0056b3; }
        .test-results {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            padding: 15px;
            margin: 10px 0;
            font-family: monospace;
            white-space: pre-wrap;
            max-height: 400px;
            overflow-y: auto;
        }
        .warning {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            color: #856404;
            padding: 10px;
            border-radius: 4px;
            margin: 10px 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ”¬ Tests des Cas Limites</h1>
        <p>Tests spÃ©cialisÃ©s pour valider le comportement dans des situations extrÃªmes</p>
        
        <div class="warning">
            âš ï¸ Ces tests peuvent gÃ©nÃ©rer des erreurs intentionnelles pour valider la robustesse du systÃ¨me.
        </div>
        
        <div class="container">
            <h2>ğŸ¯ Tests Disponibles</h2>
            <button onclick="runAllEdgeCases()">ğŸš€ Tous les Cas Limites</button>
            <button onclick="testEmptyTable()">ğŸ“‹ Table Vide</button>
            <button onclick="testMissingTable()">â“ Table Inexistante</button>
            <button onclick="testCorruptedData()">ğŸ’¥ DonnÃ©es Corrompues</button>
            <button onclick="testLargeContent()">ğŸ“Š Contenu Volumineux</button>
            <button onclick="testSpecialChars()">ğŸ”¤ CaractÃ¨res ExtrÃªmes</button>
            <button onclick="testStorageLimit()">ğŸ’¾ Limite de Stockage</button>
            <button onclick="clearResults()">ğŸ§¹ Effacer</button>
        </div>

        <div class="container">
            <h2>ğŸ“‹ Tables de Test</h2>
            
            <h3>Table Vide</h3>
            <div class="prose prose-base dark:prose-invert max-w-none">
                <table id="empty-table" class="test-table min-w-full">
                    <thead>
                        <tr>
                            <th>Colonne</th>
                        </tr>
                    </thead>
                    <tbody>
                        <!-- Vide intentionnellement -->
                    </tbody>
                </table>
            </div>

            <h3>Table pour Tests ExtrÃªmes</h3>
            <div class="prose prose-base dark:prose-invert max-w-none">
                <table id="extreme-table" class="test-table min-w-full">
                    <thead>
                        <tr>
                            <th>Test</th>
                            <th>Valeur</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Normal</td>
                            <td>Valeur</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>

        <div class="container">
            <h2>ğŸ“Š RÃ©sultats</h2>
            <div id="test-results" class="test-results">
Aucun test exÃ©cutÃ©.
Cliquez sur un bouton de test pour commencer.
            </div>
        </div>
    </div>

    <!-- Charger le systÃ¨me de stockage -->
    <script src="menu_storage.js"></script>

    <script>
        let testResults = [];

        function log(message) {
            console.log(message);
            testResults.push(`${new Date().toLocaleTimeString()} - ${message}`);
            updateResultsDisplay();
        }

        function updateResultsDisplay() {
            document.getElementById('test-results').textContent = testResults.join('\n');
        }

        function clearResults() {
            testResults = [];
            updateResultsDisplay();
        }

        async function testEmptyTable() {
            log('ğŸ§ª === TEST: TABLE VIDE ===');
            
            try {
                const table = document.getElementById('empty-table');
                table.removeAttribute('data-robust-table-id');
                
                log('ğŸ“‹ Test avec table sans contenu dans tbody');

                // Tenter de sauvegarder une table vide
                const saveResult = window.claraverseStorageAPI.saveTable(table);
                log(`ğŸ’¾ Sauvegarde table vide: ${saveResult ? 'SUCCÃˆS' : 'Ã‰CHEC'}`);

                if (saveResult) {
                    // Ajouter du contenu temporaire
                    const tbody = table.querySelector('tbody');
                    const row = tbody.insertRow();
                    const cell = row.insertCell();
                    cell.textContent = 'CONTENU_TEMPORAIRE';
                    log('ğŸ“ Contenu temporaire ajoutÃ©');

                    // Tenter de restaurer
                    const restoreResult = window.claraverseStorageAPI.restoreTable(table);
                    log(`ğŸ”„ Restauration: ${restoreResult ? 'SUCCÃˆS' : 'Ã‰CHEC'}`);

                    // VÃ©rifier si la table est redevenue vide
                    const finalRows = tbody.querySelectorAll('tr').length;
                    if (finalRows === 0) {
                        log('âœ… Table correctement restaurÃ©e Ã  l\'Ã©tat vide');
                    } else {
                        log(`âŒ Table non vide aprÃ¨s restauration: ${finalRows} lignes`);
                    }
                } else {
                    log('â„¹ï¸ Sauvegarde refusÃ©e pour table vide (comportement attendu)');
                }

            } catch (error) {
                log(`âŒ ERREUR: ${error.message}`);
            }
        }

        async function testMissingTable() {
            log('ğŸ§ª === TEST: TABLE INEXISTANTE ===');
            
            try {
                // CrÃ©er un Ã©lÃ©ment qui n'est pas une table
                const fakeTable = document.createElement('div');
                fakeTable.innerHTML = '<p>Pas une table</p>';
                
                log('â“ Test avec Ã©lÃ©ment non-table');

                // Tenter de sauvegarder
                const saveResult = window.claraverseStorageAPI.saveTable(fakeTable);
                log(`ğŸ’¾ Sauvegarde Ã©lÃ©ment non-table: ${saveResult ? 'SUCCÃˆS' : 'Ã‰CHEC'}`);

                // Tenter de restaurer
                const restoreResult = window.claraverseStorageAPI.restoreTable(fakeTable);
                log(`ğŸ”„ Restauration Ã©lÃ©ment non-table: ${restoreResult ? 'SUCCÃˆS' : 'Ã‰CHEC'}`);

                // Test avec null
                try {
                    const nullSave = window.claraverseStorageAPI.saveTable(null);
                    log(`ğŸ’¾ Sauvegarde null: ${nullSave ? 'SUCCÃˆS' : 'Ã‰CHEC'}`);
                } catch (nullError) {
                    log(`ğŸ’¾ Sauvegarde null: ERREUR (${nullError.message})`);
                }

                // Test avec undefined
                try {
                    const undefinedSave = window.claraverseStorageAPI.saveTable(undefined);
                    log(`ğŸ’¾ Sauvegarde undefined: ${undefinedSave ? 'SUCCÃˆS' : 'Ã‰CHEC'}`);
                } catch (undefinedError) {
                    log(`ğŸ’¾ Sauvegarde undefined: ERREUR (${undefinedError.message})`);
                }

                log('âœ… Tests d\'Ã©lÃ©ments invalides terminÃ©s');

            } catch (error) {
                log(`âŒ ERREUR: ${error.message}`);
            }
        }

        async function testCorruptedData() {
            log('ğŸ§ª === TEST: DONNÃ‰ES CORROMPUES ===');
            
            try {
                const table = document.getElementById('extreme-table');
                table.removeAttribute('data-robust-table-id');
                
                // Sauvegarder normalement d'abord
                const cell = table.querySelector('td');
                cell.textContent = 'DONNÃ‰ES_ORIGINALES';
                
                const saveResult = window.claraverseStorageAPI.saveTable(table);
                log(`ğŸ’¾ Sauvegarde initiale: ${saveResult ? 'SUCCÃˆS' : 'Ã‰CHEC'}`);

                if (saveResult) {
                    const tableId = table.getAttribute('data-robust-table-id');
                    log(`ğŸ”‘ ID de table: ${tableId ? tableId.substring(0, 30) + '...' : 'AUCUN'}`);

                    if (tableId) {
                        // Corrompre les donnÃ©es dans localStorage
                        const originalData = localStorage.getItem(tableId);
                        log(`ğŸ“Š DonnÃ©es originales trouvÃ©es: ${originalData ? 'OUI' : 'NON'}`);

                        // Test 1: JSON invalide
                        localStorage.setItem(tableId, '{invalid json}');
                        log('ğŸ’¥ DonnÃ©es corrompues avec JSON invalide');

                        cell.textContent = 'TEMPORAIRE_1';
                        const restore1 = window.claraverseStorageAPI.restoreTable(table);
                        log(`ğŸ”„ Restauration JSON invalide: ${restore1 ? 'SUCCÃˆS' : 'Ã‰CHEC'}`);

                        // Test 2: JSON valide mais structure invalide
                        localStorage.setItem(tableId, '{"wrong": "structure"}');
                        log('ğŸ’¥ DonnÃ©es corrompues avec structure invalide');

                        cell.textContent = 'TEMPORAIRE_2';
                        const restore2 = window.claraverseStorageAPI.restoreTable(table);
                        log(`ğŸ”„ Restauration structure invalide: ${restore2 ? 'SUCCÃˆS' : 'Ã‰CHEC'}`);

                        // Test 3: DonnÃ©es vides
                        localStorage.setItem(tableId, '');
                        log('ğŸ’¥ DonnÃ©es vides');

                        cell.textContent = 'TEMPORAIRE_3';
                        const restore3 = window.claraverseStorageAPI.restoreTable(table);
                        log(`ğŸ”„ Restauration donnÃ©es vides: ${restore3 ? 'SUCCÃˆS' : 'Ã‰CHEC'}`);

                        // Restaurer les donnÃ©es originales
                        if (originalData) {
                            localStorage.setItem(tableId, originalData);
                            log('ğŸ”§ DonnÃ©es originales restaurÃ©es');
                        }
                    }
                }

                log('âœ… Tests de corruption terminÃ©s');

            } catch (error) {
                log(`âŒ ERREUR: ${error.message}`);
            }
        }

        async function testLargeContent() {
            log('ğŸ§ª === TEST: CONTENU VOLUMINEUX ===');
            
            try {
                const table = document.getElementById('extreme-table');
                table.removeAttribute('data-robust-table-id');
                
                // CrÃ©er un contenu trÃ¨s volumineux
                const largeText = 'A'.repeat(10000); // 10KB de texte
                const veryLargeText = 'B'.repeat(100000); // 100KB de texte
                
                const cells = table.querySelectorAll('td');
                
                // Test avec contenu large
                cells[0].textContent = largeText;
                cells[1].textContent = 'Normal';
                
                log(`ğŸ“Š Contenu large crÃ©Ã©: ${largeText.length} caractÃ¨res`);

                const startSave = performance.now();
                const saveResult = window.claraverseStorageAPI.saveTable(table);
                const endSave = performance.now();
                
                log(`ğŸ’¾ Sauvegarde contenu large: ${saveResult ? 'SUCCÃˆS' : 'Ã‰CHEC'} en ${(endSave - startSave).toFixed(2)}ms`);

                if (saveResult) {
                    // Modifier temporairement
                    cells[0].textContent = 'TEMP';
                    cells[1].textContent = 'TEMP';

                    const startRestore = performance.now();
                    const restoreResult = window.claraverseStorageAPI.restoreTable(table);
                    const endRestore = performance.now();
                    
                    log(`ğŸ”„ Restauration: ${restoreResult ? 'SUCCÃˆS' : 'Ã‰CHEC'} en ${(endRestore - startRestore).toFixed(2)}ms`);

                    // VÃ©rifier
                    const restoredText = cells[0].textContent;
                    if (restoredText === largeText) {
                        log('âœ… Contenu large correctement restaurÃ©');
                    } else {
                        log(`âŒ Contenu large altÃ©rÃ©: ${restoredText.length} caractÃ¨res au lieu de ${largeText.length}`);
                    }
                }

                // Test avec contenu trÃ¨s volumineux
                log('ğŸ“Š Test avec contenu trÃ¨s volumineux...');
                cells[0].textContent = veryLargeText;
                
                const startSave2 = performance.now();
                const saveResult2 = window.claraverseStorageAPI.saveTable(table);
                const endSave2 = performance.now();
                
                log(`ğŸ’¾ Sauvegarde trÃ¨s large: ${saveResult2 ? 'SUCCÃˆS' : 'Ã‰CHEC'} en ${(endSave2 - startSave2).toFixed(2)}ms`);

                // Nettoyer
                cells[0].textContent = 'Normal';
                cells[1].textContent = 'Valeur';

            } catch (error) {
                log(`âŒ ERREUR: ${error.message}`);
            }
        }

        async function testSpecialChars() {
            log('ğŸ§ª === TEST: CARACTÃˆRES EXTRÃŠMES ===');
            
            try {
                const table = document.getElementById('extreme-table');
                table.removeAttribute('data-robust-table-id');
                
                const cells = table.querySelectorAll('td');
                
                // CaractÃ¨res spÃ©ciaux extrÃªmes
                const extremeChars = [
                    'HTML: <script>alert("test")</script>',
                    'JSON: {"key": "value", "array": [1,2,3]}',
                    'Unicode: ğŸ¯ğŸš€âœ…âŒğŸ”¥ğŸ’¯ğŸ‰ğŸ”§ğŸ“ŠğŸ’¾',
                    'Accents: Ã Ã¡Ã¢Ã£Ã¤Ã¥Ã¦Ã§Ã¨Ã©ÃªÃ«Ã¬Ã­Ã®Ã¯Ã±Ã²Ã³Ã´ÃµÃ¶Ã¸Ã¹ÃºÃ»Ã¼Ã½',
                    'Symboles: Â©Â®â„¢â‚¬Â£Â¥Â§Â¶â€ â€¡â€¢â€¦â€°â€¹â€º""''â€“â€”',
                    'Math: âˆ‘âˆâˆ†âˆ‡âˆ‚âˆ«âˆâ‰ â‰¤â‰¥Â±Ã—Ã·âˆšâˆâˆˆâˆ‰âˆªâˆ©âŠ‚âŠƒ',
                    'ContrÃ´le: \n\t\r\\',
                    'Quotes: "double" \'single\' `backtick`'
                ];

                for (let i = 0; i < extremeChars.length; i++) {
                    const testChar = extremeChars[i];
                    log(`ğŸ”¤ Test ${i + 1}/${extremeChars.length}: ${testChar.substring(0, 30)}...`);
                    
                    cells[0].textContent = testChar;
                    cells[1].textContent = `Test ${i + 1}`;

                    const saveResult = window.claraverseStorageAPI.saveTable(table);
                    
                    if (saveResult) {
                        cells[0].textContent = 'TEMP';
                        cells[1].textContent = 'TEMP';
                        
                        const restoreResult = window.claraverseStorageAPI.restoreTable(table);
                        
                        if (restoreResult && cells[0].textContent === testChar) {
                            log(`âœ… CaractÃ¨res ${i + 1} OK`);
                        } else {
                            log(`âŒ CaractÃ¨res ${i + 1} Ã‰CHOUÃ‰`);
                        }
                    } else {
                        log(`âŒ Sauvegarde ${i + 1} Ã‰CHOUÃ‰E`);
                    }
                    
                    // Petite pause pour Ã©viter la surcharge
                    await new Promise(resolve => setTimeout(resolve, 10));
                }

                // Nettoyer
                cells[0].textContent = 'Normal';
                cells[1].textContent = 'Valeur';

                log('âœ… Tests de caractÃ¨res extrÃªmes terminÃ©s');

            } catch (error) {
                log(`âŒ ERREUR: ${error.message}`);
            }
        }

        async function testStorageLimit() {
            log('ğŸ§ª === TEST: LIMITE DE STOCKAGE ===');
            
            try {
                // Estimer l'espace localStorage disponible
                let testKey = 'test_storage_limit';
                let testData = '';
                let maxSize = 0;

                log('ğŸ“Š Estimation de la limite localStorage...');

                try {
                    // Test rapide pour estimer la limite
                    for (let size = 1000; size < 10000000; size *= 2) {
                        testData = 'x'.repeat(size);
                        localStorage.setItem(testKey, testData);
                        maxSize = size;
                        localStorage.removeItem(testKey);
                    }
                } catch (e) {
                    log(`ğŸ“Š Limite estimÃ©e: ~${maxSize} caractÃ¨res`);
                }

                // Test avec le systÃ¨me de tables
                const table = document.getElementById('extreme-table');
                table.removeAttribute('data-robust-table-id');
                
                const cell = table.querySelector('td');
                
                // CrÃ©er un contenu proche de la limite
                const largeContent = 'X'.repeat(Math.min(maxSize / 10, 500000));
                cell.textContent = largeContent;
                
                log(`ğŸ’¾ Test sauvegarde avec ${largeContent.length} caractÃ¨res...`);

                const startTime = performance.now();
                const saveResult = window.claraverseStorageAPI.saveTable(table);
                const endTime = performance.now();
                
                if (saveResult) {
                    log(`âœ… Sauvegarde volumineuse rÃ©ussie en ${(endTime - startTime).toFixed(2)}ms`);
                    
                    // Test de restauration
                    cell.textContent = 'TEMP';
                    const restoreStart = performance.now();
                    const restoreResult = window.claraverseStorageAPI.restoreTable(table);
                    const restoreEnd = performance.now();
                    
                    if (restoreResult) {
                        log(`âœ… Restauration volumineuse rÃ©ussie en ${(restoreEnd - restoreStart).toFixed(2)}ms`);
                    } else {
                        log(`âŒ Restauration volumineuse Ã©chouÃ©e`);
                    }
                } else {
                    log(`âŒ Sauvegarde volumineuse Ã©chouÃ©e`);
                }

                // Nettoyer
                cell.textContent = 'Normal';
                localStorage.removeItem(testKey);

            } catch (error) {
                log(`âŒ ERREUR: ${error.message}`);
            }
        }

        async function runAllEdgeCases() {
            log('ğŸš€ === DÃ‰BUT DES TESTS DE CAS LIMITES ===');
            
            const startTime = performance.now();
            
            await testEmptyTable();
            await new Promise(resolve => setTimeout(resolve, 100));
            
            await testMissingTable();
            await new Promise(resolve => setTimeout(resolve, 100));
            
            await testCorruptedData();
            await new Promise(resolve => setTimeout(resolve, 100));
            
            await testLargeContent();
            await new Promise(resolve => setTimeout(resolve, 100));
            
            await testSpecialChars();
            await new Promise(resolve => setTimeout(resolve, 100));
            
            await testStorageLimit();
            
            const endTime = performance.now();
            const totalTime = endTime - startTime;
            
            log(`ğŸ === TESTS DE CAS LIMITES TERMINÃ‰S en ${totalTime.toFixed(2)}ms ===`);
            
            // Compter les rÃ©sultats
            const successCount = testResults.filter(result => result.includes('âœ…')).length;
            const failCount = testResults.filter(result => result.includes('âŒ')).length;
            
            log(`ğŸ“Š RÃ‰SUMÃ‰: ${successCount} succÃ¨s, ${failCount} Ã©checs/erreurs`);
        }

        // Initialisation
        document.addEventListener('DOMContentLoaded', function() {
            log('ğŸ”¬ Tests des cas limites chargÃ©s');
            log('âš ï¸ Ces tests peuvent gÃ©nÃ©rer des erreurs intentionnelles');
        });
    </script>
</body>
</html>